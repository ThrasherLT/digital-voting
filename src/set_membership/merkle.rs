//! This is a custom implementation of a Merkle Tree, used in set membership ZKPs.
//! Other crates were too overbloated and not flexible enough.

use thiserror::Error;

/// Error type for Merkle Tree operations.
#[derive(Error, Debug)]
pub enum Error {
    /// The entered element index was larger than there are elements in the tree.
    #[error("Specified element is out of bounds for this Merkle Tree {}/{}", .0, .1)]
    ElementOutOfBounds(usize, usize),
    /// Occurs if a Merkle tree is being creates without any nodes.
    #[error("Merkle Tree cannot be empty")]
    EmptyTree,
}
type Result<T> = std::result::Result<T, Error>;

/// A struct containing all the info for Merkle Proof for a leaf in a Merkle Tree.
pub struct MerkleProof<H> {
    /// The index of the leaf for which the proof is generated.
    _leaf_index: usize,
    /// The root of the Merkle Tree.
    _root: H,
    /// The proof for the leaf.
    proof: Vec<H>,
    /// The path to the leaf from the root. The index of the path element corresponds to the index of the proof element.
    /// false means that the proof element should be on the right side of the hash.
    /// true means that the proof element should be on the left side of the hash.
    path: Vec<bool>,
}

/// A struct representing a Merkle Tree itself.
pub struct MerkleTree<T, H, N, L>
where
    N: Fn(&H, &H) -> H,
    L: Fn(&T) -> H,
{
    /// The leaves of the Merkle Tree containing the unhashed raw input data.
    leaves: Vec<T>,
    /// The nodes of the Merkle Tree containing the hashes of the leaves and all the subsequent
    /// neighbouring node hashes. The last element is the root of the Merkle tree.
    /// These will be generated by the Merkle Tree.
    nodes: Vec<H>,
    /// The function used to hash two nodes together.
    node_hash_function: N,
    /// The function used to hash a leaf.
    leaf_hash_function: L,
}

impl<T, H, N, L> MerkleTree<T, H, N, L>
where
    N: Fn(&H, &H) -> H,
    L: Fn(&T) -> H,
    H: PartialEq + Clone,
    T: Clone,
{
    /// Create a new Merkle Tree with the given leaves and hash functions.
    ///
    /// # Arguments
    ///
    /// - `leaves` - The leaves of the Merkle Tree containing the unhashed raw input data.
    /// - `node_hash_function` - The function used to hash two nodes together.
    /// - `leaf_hash_function` - The function used to hash a leaf.
    ///
    /// # Returns
    ///
    /// A new Merkle Tree instance.
    ///
    /// # Example
    ///
    /// ```
    /// use digital_voting::set_membership::merkle::MerkleTree;
    /// use digital_voting::set_membership::poseidon_hasher;
    ///
    /// let leaves = vec![1u64, 2u64, 3u64];
    /// let tree = MerkleTree::new(
    ///     leaves.clone(),
    ///     |a, b| poseidon_hasher::hash([*a, *b]),
    ///     |x| poseidon_hasher::hash([x.into(), x.into()])
    /// );
    /// ```
    ///
    /// # Errors
    ///
    /// If the Merkle Tree is empty.
    ///
    /// # Panics
    ///
    /// If the node_hash_function or leaf_hash_function panics.
    pub fn new(leaves: Vec<T>, node_hash_function: N, leaf_hash_function: L) -> Result<Self> {
        if leaves.is_empty() {
            return Err(Error::EmptyTree);
        }

        let nodes = vec![];
        let mut new_tree = Self {
            leaves,
            nodes,
            node_hash_function,
            leaf_hash_function,
        };
        new_tree.build_tree();
        Ok(new_tree)
    }

    /// Build the bottom level of the Merkle Tree.
    ///
    /// # Returns
    ///
    /// The bottom level of the Merkle Tree containing the hashed leaves.
    fn build_bottom_level(&mut self) -> Vec<H> {
        self.leaves
            .iter()
            .map(|leaf| (self.leaf_hash_function)(leaf))
            .collect()
    }

    /// Build the entire Merkle Tree.
    ///
    /// This function will hash the leaves and then the nodes to build the whole Merkle tree.
    fn build_tree(&mut self) {
        let mut current_level = self.build_bottom_level();
        while current_level.len() > 1 {
            let mut next_level = vec![];
            for chunk in current_level.chunks(2) {
                let hash = if chunk.len() == 2 {
                    (self.node_hash_function)(&chunk[0], &chunk[1])
                } else {
                    (self.node_hash_function)(&chunk[0], &chunk[0])
                };
                next_level.push(hash);
            }
            self.nodes.extend(current_level);
            current_level = next_level;
        }
        self.nodes.extend(current_level);
    }

    /// Get the root of the Merkle Tree.
    ///
    /// # Returns
    ///
    /// The root of the Merkle Tree.
    ///
    /// # Panics
    ///
    /// If the Merkle Tree is empty, which should not happen.
    ///
    /// # Example
    ///
    /// ```
    /// use digital_voting::set_membership::merkle::MerkleTree;
    /// use digital_voting::set_membership::poseidon_hasher;
    ///
    /// let leaves = vec![1u64, 2u64, 3u64];
    /// let tree = MerkleTree::new(
    ///     leaves.clone(),
    ///     |a, b| poseidon_hasher::hash([*a, *b]),
    ///     |x| poseidon_hasher::hash([x.into(), x.into()])
    /// ).unwrap();
    /// let root = tree.get_root();
    /// ```
    pub fn get_root(&self) -> H {
        self.nodes.last().unwrap().clone()
    }

    /// Get the Merkle Proof for a leaf in the Merkle Tree.
    ///
    /// # Arguments
    ///
    /// - `leaf_index` - The index of the leaf for which the proof is generated.
    ///
    /// # Returns
    ///
    /// The Merkle Proof for the leaf.
    ///
    /// # Errors
    ///
    /// If the leaf index is out of bounds.
    ///
    /// # Example
    ///
    /// ```
    /// use digital_voting::set_membership::merkle::MerkleTree;
    /// use digital_voting::set_membership::poseidon_hasher;
    ///
    /// let leaves = vec![1u64, 2u64, 3u64];
    /// let tree = MerkleTree::new(
    ///     leaves.clone(),
    ///     |a, b| poseidon_hasher::hash([*a, *b]),
    ///     |x| poseidon_hasher::hash([x.into(), x.into()])
    /// ).unwrap();
    /// let proof = tree.get_proof(1).unwrap();
    /// ```
    pub fn get_proof(&self, leaf_index: usize) -> Result<MerkleProof<H>> {
        if leaf_index >= self.leaves.len() {
            return Err(Error::ElementOutOfBounds(leaf_index, self.leaves.len()));
        }
        let mut proof = MerkleProof {
            _leaf_index: leaf_index,
            _root: self.nodes.last().unwrap().clone(),
            proof: vec![],
            path: vec![],
        };
        let mut cap = self.leaves.len();
        let mut current_level = 0;
        let mut current_index = leaf_index;
        while cap > 1 {
            let sibling_index = if current_index % 2 == 0 {
                current_index + 1
            } else {
                current_index - 1
            };
            let sibling = if sibling_index < cap {
                self.nodes[current_level + sibling_index].clone()
            } else {
                // Last node without a pair, so returning itself.
                self.nodes[current_level + current_index].clone()
            };
            proof.proof.push(sibling);
            proof.path.push(current_index % 2 == 0);
            current_index /= 2;
            current_level += cap;
            if cap % 2 == 1 {
                cap += 1;
            }
            cap /= 2;
        }

        Ok(proof)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // TODO add tests with more different data types.
    // TODO use a generic hasher so this file is universal.
    use crate::set_membership::poseidon_hasher;

    #[test]
    fn test_merkle_tree_empty() {
        let leaves: Vec<u64> = vec![];
        let tree = MerkleTree::new(
            leaves.clone(),
            |a, b| poseidon_hasher::hash([*a, *b]),
            |x| poseidon_hasher::hash([x.into(), x.into()]),
        );
        assert!(tree.is_err());
    }

    #[test]
    fn test_merkle_tree_proof_out_of_bounds() {
        let leaves = vec![1u64, 2u64, 3u64];
        let tree = MerkleTree::new(
            leaves.clone(),
            |a, b| poseidon_hasher::hash([*a, *b]),
            |x| poseidon_hasher::hash([x.into(), x.into()]),
        )
        .unwrap();
        assert!(tree.get_proof(leaves.len()).is_err());
    }

    #[test]
    fn test_merkle_tree() {
        let leaves = vec![1u64, 2u64, 3u64];
        let tree = MerkleTree::new(
            leaves.clone(),
            |a, b| poseidon_hasher::hash([*a, *b]),
            |x| poseidon_hasher::hash([x.into(), x.into()]),
        )
        .unwrap();
        let root = tree.get_root();

        // Manually calculate all the hashes and the root.
        let hash_0 = poseidon_hasher::hash([leaves[0].into(), leaves[0].into()]);
        let hash_1 = poseidon_hasher::hash([leaves[1].into(), leaves[1].into()]);
        let hash_2 = poseidon_hasher::hash([leaves[2].into(), leaves[2].into()]);
        let hash_01 = poseidon_hasher::hash([hash_0, hash_1]);
        let hash_22 = poseidon_hasher::hash([hash_2, hash_2]);
        let calc_root = poseidon_hasher::hash([hash_01, hash_22]);

        let calc_proof = vec![
            vec![hash_1, hash_22],
            vec![hash_0, hash_22],
            vec![hash_2, hash_01],
        ];
        let calc_path = vec![vec![true, true], vec![false, true], vec![true, false]];

        assert_eq!(root, calc_root);

        // Looping through all the leaves to ensure that no edge cases are missed.
        for leaf_index in 0..leaves.len() {
            let proof = tree.get_proof(leaf_index).unwrap();

            assert_eq!(calc_path[leaf_index], proof.path);
            assert_eq!(calc_proof[leaf_index], proof.proof);
            assert_eq!(proof._root, root);
            assert_eq!(leaf_index, proof._leaf_index);
        }
    }
}
